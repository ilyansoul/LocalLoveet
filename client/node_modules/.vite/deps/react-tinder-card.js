import {
  require_react_dom
} from "./chunk-INWTSBAG.js";
import {
  require_react
} from "./chunk-C3MNZ72B.js";
import {
  __commonJS,
  __publicField
} from "./chunk-JEXKZRFY.js";

// node_modules/@react-spring/rafz/dist/index.js
var require_dist = __commonJS({
  "node_modules/@react-spring/rafz/dist/index.js"(exports, module) {
    "use strict";
    var T = Object.defineProperty;
    var S = Object.getOwnPropertyDescriptor;
    var U = Object.getOwnPropertyNames;
    var g = Object.prototype.hasOwnProperty;
    var E = (e, t) => {
      for (var a2 in t)
        T(e, a2, { get: t[a2], enumerable: true });
    };
    var L = (e, t, a2, o) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let l of U(t))
          !g.call(e, l) && l !== a2 && T(e, l, { get: () => t[l], enumerable: !(o = S(t, l)) || o.enumerable });
      return e;
    };
    var A = (e) => L(T({}, "__esModule", { value: true }), e);
    var N = {};
    E(N, { __raf: () => I, raf: () => n });
    module.exports = A(N);
    var f = r();
    var n = (e) => s(e, f);
    var m = r();
    n.write = (e) => s(e, m);
    var c = r();
    n.onStart = (e) => s(e, c);
    var h = r();
    n.onFrame = (e) => s(e, h);
    var p = r();
    n.onFinish = (e) => s(e, p);
    var d = [];
    n.setTimeout = (e, t) => {
      let a2 = n.now() + t, o = () => {
        let F = d.findIndex((R) => R.cancel == o);
        ~F && d.splice(F, 1), i -= ~F ? 1 : 0;
      }, l = { time: a2, handler: e, cancel: o };
      return d.splice(v(a2), 0, l), i += 1, b(), l;
    };
    var v = (e) => ~(~d.findIndex((t) => t.time > e) || ~d.length);
    n.cancel = (e) => {
      c.delete(e), h.delete(e), p.delete(e), f.delete(e), m.delete(e);
    };
    n.sync = (e) => {
      y = true, n.batchedUpdates(e), y = false;
    };
    n.throttle = (e) => {
      let t;
      function a2() {
        try {
          e(...t);
        } finally {
          t = null;
        }
      }
      function o(...l) {
        t = l, n.onStart(a2);
      }
      return o.handler = e, o.cancel = () => {
        c.delete(a2), t = null;
      }, o;
    };
    var w = typeof window < "u" ? window.requestAnimationFrame : () => {
    };
    n.use = (e) => w = e;
    n.now = typeof performance < "u" ? () => performance.now() : Date.now;
    n.batchedUpdates = (e) => e();
    n.catch = console.error;
    n.frameLoop = "always";
    n.advance = () => {
      n.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : Q();
    };
    var u = -1;
    var i = 0;
    var y = false;
    function s(e, t) {
      y ? (t.delete(e), e(0)) : (t.add(e), b());
    }
    function b() {
      u < 0 && (u = 0, n.frameLoop !== "demand" && w(x));
    }
    function C() {
      u = -1;
    }
    function x() {
      ~u && (w(x), n.batchedUpdates(Q));
    }
    function Q() {
      let e = u;
      u = n.now();
      let t = v(u);
      if (t && (z(d.splice(0, t), (a2) => a2.handler()), i -= t), !i) {
        C();
        return;
      }
      c.flush(), f.flush(e ? Math.min(64, u - e) : 16.667), h.flush(), m.flush(), p.flush();
    }
    function r() {
      let e = /* @__PURE__ */ new Set(), t = e;
      return { add(a2) {
        i += t == e && !e.has(a2) ? 1 : 0, e.add(a2);
      }, delete(a2) {
        return i -= t == e && e.has(a2) ? 1 : 0, e.delete(a2);
      }, flush(a2) {
        t.size && (e = /* @__PURE__ */ new Set(), i -= t.size, z(t, (o) => o(a2) && e.add(o)), i += e.size, t = e);
      } };
    }
    function z(e, t) {
      e.forEach((a2) => {
        try {
          t(a2);
        } catch (o) {
          n.catch(o);
        }
      });
    }
    var I = { count() {
      return i;
    }, isRunning() {
      return u >= 0;
    }, clear() {
      u = -1, d = [], c = r(), f = r(), h = r(), m = r(), p = r(), i = 0;
    } };
  }
});

// node_modules/@react-spring/shared/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@react-spring/shared/dist/index.js"(exports, module) {
    "use strict";
    var K = Object.defineProperty;
    var _e = Object.getOwnPropertyDescriptor;
    var Ze = Object.getOwnPropertyNames;
    var Xe = Object.prototype.hasOwnProperty;
    var he = (e, t) => {
      for (var r in t)
        K(e, r, { get: t[r], enumerable: true });
    };
    var Ye = (e, t, r, n) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let o of Ze(t))
          !Xe.call(e, o) && o !== r && K(e, o, { get: () => t[o], enumerable: !(n = _e(t, o)) || n.enumerable });
      return e;
    };
    var Je = (e) => Ye(K({}, "__esModule", { value: true }), e);
    var $t = {};
    he($t, { FluidValue: () => se, Globals: () => p, addFluidObserver: () => xt, callFluidObserver: () => Ce, callFluidObservers: () => bt, clamp: () => Y, colorToRgba: () => P, colors: () => it, createInterpolator: () => q, createStringInterpolator: () => vt, defineHidden: () => et, deprecateDirectCall: () => Tt, deprecateInterpolate: () => Ot, each: () => ye, eachProp: () => rt, easings: () => dt, flush: () => ge, flushCalls: () => ot, frameLoop: () => Oe, getFluidObservers: () => mt, getFluidValue: () => ue, hasFluidValue: () => pt, hex3: () => ne, hex4: () => oe, hex6: () => fe, hex8: () => ae, hsl: () => te, hsla: () => re, is: () => u, isAnimatedString: () => Ft, isEqual: () => tt, isSSR: () => m, noop: () => N, onResize: () => me, onScroll: () => Rt, once: () => pe, prefix: () => U, raf: () => Ne.raf, removeFluidObserver: () => ht, rgb: () => J, rgba: () => ee, setFluidGetter: () => ze, toArray: () => nt, useConstant: () => At, useForceUpdate: () => Mt, useIsomorphicLayoutEffect: () => S, useMemoOne: () => Ct, useOnce: () => Lt, usePrev: () => Pt, useReducedMotion: () => qt });
    module.exports = Je($t);
    var p = {};
    he(p, { assign: () => _, colors: () => c, createStringInterpolator: () => A, skipAnimation: () => Ee, to: () => ve, willAdvance: () => M });
    var O = require_dist();
    function N() {
    }
    var et = (e, t, r) => Object.defineProperty(e, t, { value: r, writable: true, configurable: true });
    var u = { arr: Array.isArray, obj: (e) => !!e && e.constructor.name === "Object", fun: (e) => typeof e == "function", str: (e) => typeof e == "string", num: (e) => typeof e == "number", und: (e) => e === void 0 };
    function tt(e, t) {
      if (u.arr(e)) {
        if (!u.arr(t) || e.length !== t.length)
          return false;
        for (let r = 0; r < e.length; r++)
          if (e[r] !== t[r])
            return false;
        return true;
      }
      return e === t;
    }
    var ye = (e, t) => e.forEach(t);
    function rt(e, t, r) {
      if (u.arr(e)) {
        for (let n = 0; n < e.length; n++)
          t.call(r, e[n], `${n}`);
        return;
      }
      for (let n in e)
        e.hasOwnProperty(n) && t.call(r, e[n], n);
    }
    var nt = (e) => u.und(e) ? [] : u.arr(e) ? e : [e];
    function ge(e, t) {
      if (e.size) {
        let r = Array.from(e);
        e.clear(), ye(r, t);
      }
    }
    var ot = (e, ...t) => ge(e, (r) => r(...t));
    var m = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
    var A;
    var ve;
    var c = null;
    var Ee = false;
    var M = N;
    var _ = (e) => {
      e.to && (ve = e.to), e.now && (O.raf.now = e.now), e.colors !== void 0 && (c = e.colors), e.skipAnimation != null && (Ee = e.skipAnimation), e.createStringInterpolator && (A = e.createStringInterpolator), e.requestAnimationFrame && O.raf.use(e.requestAnimationFrame), e.batchedUpdates && (O.raf.batchedUpdates = e.batchedUpdates), e.willAdvance && (M = e.willAdvance), e.frameLoop && (O.raf.frameLoop = e.frameLoop);
    };
    var w = require_dist();
    var T = /* @__PURE__ */ new Set();
    var l = [];
    var Z = [];
    var C = 0;
    var Oe = { get idle() {
      return !T.size && !l.length;
    }, start(e) {
      C > e.priority ? (T.add(e), w.raf.onStart(ft)) : (we(e), (0, w.raf)(X));
    }, advance: X, sort(e) {
      if (C)
        w.raf.onFrame(() => Oe.sort(e));
      else {
        let t = l.indexOf(e);
        ~t && (l.splice(t, 1), Te(e));
      }
    }, clear() {
      l = [], T.clear();
    } };
    function ft() {
      T.forEach(we), T.clear(), (0, w.raf)(X);
    }
    function we(e) {
      l.includes(e) || Te(e);
    }
    function Te(e) {
      l.splice(at(l, (t) => t.priority > e.priority), 0, e);
    }
    function X(e) {
      let t = Z;
      for (let r = 0; r < l.length; r++) {
        let n = l[r];
        C = n.priority, n.idle || (M(n), n.advance(e), n.idle || t.push(n));
      }
      return C = 0, Z = l, Z.length = 0, l = t, l.length > 0;
    }
    function at(e, t) {
      let r = e.findIndex(t);
      return r < 0 ? e.length : r;
    }
    var Y = (e, t, r) => Math.min(Math.max(r, e), t);
    var it = { transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199 };
    var d = "[-+]?\\d*\\.?\\d+";
    var z = d + "%";
    function L(...e) {
      return "\\(\\s*(" + e.join(")\\s*,\\s*(") + ")\\s*\\)";
    }
    var J = new RegExp("rgb" + L(d, d, d));
    var ee = new RegExp("rgba" + L(d, d, d, d));
    var te = new RegExp("hsl" + L(d, z, z));
    var re = new RegExp("hsla" + L(d, z, z, d));
    var ne = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var oe = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
    var fe = /^#([0-9a-fA-F]{6})$/;
    var ae = /^#([0-9a-fA-F]{8})$/;
    function Se(e) {
      let t;
      return typeof e == "number" ? e >>> 0 === e && e >= 0 && e <= 4294967295 ? e : null : (t = fe.exec(e)) ? parseInt(t[1] + "ff", 16) >>> 0 : c && c[e] !== void 0 ? c[e] : (t = J.exec(e)) ? (y(t[1]) << 24 | y(t[2]) << 16 | y(t[3]) << 8 | 255) >>> 0 : (t = ee.exec(e)) ? (y(t[1]) << 24 | y(t[2]) << 16 | y(t[3]) << 8 | ke(t[4])) >>> 0 : (t = ne.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + "ff", 16) >>> 0 : (t = ae.exec(e)) ? parseInt(t[1], 16) >>> 0 : (t = oe.exec(e)) ? parseInt(t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + t[4] + t[4], 16) >>> 0 : (t = te.exec(e)) ? (Fe(Ie(t[1]), V(t[2]), V(t[3])) | 255) >>> 0 : (t = re.exec(e)) ? (Fe(Ie(t[1]), V(t[2]), V(t[3])) | ke(t[4])) >>> 0 : null;
    }
    function ie(e, t, r) {
      return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
    }
    function Fe(e, t, r) {
      let n = r < 0.5 ? r * (1 + t) : r + t - r * t, o = 2 * r - n, f = ie(o, n, e + 1 / 3), i = ie(o, n, e), s = ie(o, n, e - 1 / 3);
      return Math.round(f * 255) << 24 | Math.round(i * 255) << 16 | Math.round(s * 255) << 8;
    }
    function y(e) {
      let t = parseInt(e, 10);
      return t < 0 ? 0 : t > 255 ? 255 : t;
    }
    function Ie(e) {
      return (parseFloat(e) % 360 + 360) % 360 / 360;
    }
    function ke(e) {
      let t = parseFloat(e);
      return t < 0 ? 0 : t > 1 ? 255 : Math.round(t * 255);
    }
    function V(e) {
      let t = parseFloat(e);
      return t < 0 ? 0 : t > 100 ? 1 : t / 100;
    }
    function P(e) {
      let t = Se(e);
      if (t === null)
        return e;
      t = t || 0;
      let r = (t & 4278190080) >>> 24, n = (t & 16711680) >>> 16, o = (t & 65280) >>> 8, f = (t & 255) / 255;
      return `rgba(${r}, ${n}, ${o}, ${f})`;
    }
    var q = (e, t, r) => {
      if (u.fun(e))
        return e;
      if (u.arr(e))
        return q({ range: e, output: t, extrapolate: r });
      if (u.str(e.output[0]))
        return A(e);
      let n = e, o = n.output, f = n.range || [0, 1], i = n.extrapolateLeft || n.extrapolate || "extend", s = n.extrapolateRight || n.extrapolate || "extend", h = n.easing || ((a2) => a2);
      return (a2) => {
        let R = lt(a2, f);
        return ut(a2, f[R], f[R + 1], o[R], o[R + 1], h, i, s, n.map);
      };
    };
    function ut(e, t, r, n, o, f, i, s, h) {
      let a2 = h ? h(e) : e;
      if (a2 < t) {
        if (i === "identity")
          return a2;
        i === "clamp" && (a2 = t);
      }
      if (a2 > r) {
        if (s === "identity")
          return a2;
        s === "clamp" && (a2 = r);
      }
      return n === o ? n : t === r ? e <= t ? n : o : (t === -1 / 0 ? a2 = -a2 : r === 1 / 0 ? a2 = a2 - t : a2 = (a2 - t) / (r - t), a2 = f(a2), n === -1 / 0 ? a2 = -a2 : o === 1 / 0 ? a2 = a2 + n : a2 = a2 * (o - n) + n, a2);
    }
    function lt(e, t) {
      for (var r = 1; r < t.length - 1 && !(t[r] >= e); ++r)
        ;
      return r - 1;
    }
    var ct = (e, t = "end") => (r) => {
      r = t === "end" ? Math.min(r, 0.999) : Math.max(r, 1e-3);
      let n = r * e, o = t === "end" ? Math.floor(n) : Math.ceil(n);
      return Y(0, 1, o / e);
    };
    var Q = 1.70158;
    var $ = Q * 1.525;
    var Re = Q + 1;
    var Ae = 2 * Math.PI / 3;
    var Me = 2 * Math.PI / 4.5;
    var G = (e) => e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
    var dt = { linear: (e) => e, easeInQuad: (e) => e * e, easeOutQuad: (e) => 1 - (1 - e) * (1 - e), easeInOutQuad: (e) => e < 0.5 ? 2 * e * e : 1 - Math.pow(-2 * e + 2, 2) / 2, easeInCubic: (e) => e * e * e, easeOutCubic: (e) => 1 - Math.pow(1 - e, 3), easeInOutCubic: (e) => e < 0.5 ? 4 * e * e * e : 1 - Math.pow(-2 * e + 2, 3) / 2, easeInQuart: (e) => e * e * e * e, easeOutQuart: (e) => 1 - Math.pow(1 - e, 4), easeInOutQuart: (e) => e < 0.5 ? 8 * e * e * e * e : 1 - Math.pow(-2 * e + 2, 4) / 2, easeInQuint: (e) => e * e * e * e * e, easeOutQuint: (e) => 1 - Math.pow(1 - e, 5), easeInOutQuint: (e) => e < 0.5 ? 16 * e * e * e * e * e : 1 - Math.pow(-2 * e + 2, 5) / 2, easeInSine: (e) => 1 - Math.cos(e * Math.PI / 2), easeOutSine: (e) => Math.sin(e * Math.PI / 2), easeInOutSine: (e) => -(Math.cos(Math.PI * e) - 1) / 2, easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * e - 10), easeOutExpo: (e) => e === 1 ? 1 : 1 - Math.pow(2, -10 * e), easeInOutExpo: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? Math.pow(2, 20 * e - 10) / 2 : (2 - Math.pow(2, -20 * e + 10)) / 2, easeInCirc: (e) => 1 - Math.sqrt(1 - Math.pow(e, 2)), easeOutCirc: (e) => Math.sqrt(1 - Math.pow(e - 1, 2)), easeInOutCirc: (e) => e < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * e, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * e + 2, 2)) + 1) / 2, easeInBack: (e) => Re * e * e * e - Q * e * e, easeOutBack: (e) => 1 + Re * Math.pow(e - 1, 3) + Q * Math.pow(e - 1, 2), easeInOutBack: (e) => e < 0.5 ? Math.pow(2 * e, 2) * (($ + 1) * 2 * e - $) / 2 : (Math.pow(2 * e - 2, 2) * (($ + 1) * (e * 2 - 2) + $) + 2) / 2, easeInElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : -Math.pow(2, 10 * e - 10) * Math.sin((e * 10 - 10.75) * Ae), easeOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : Math.pow(2, -10 * e) * Math.sin((e * 10 - 0.75) * Ae) + 1, easeInOutElastic: (e) => e === 0 ? 0 : e === 1 ? 1 : e < 0.5 ? -(Math.pow(2, 20 * e - 10) * Math.sin((20 * e - 11.125) * Me)) / 2 : Math.pow(2, -20 * e + 10) * Math.sin((20 * e - 11.125) * Me) / 2 + 1, easeInBounce: (e) => 1 - G(1 - e), easeOutBounce: G, easeInOutBounce: (e) => e < 0.5 ? (1 - G(1 - 2 * e)) / 2 : (1 + G(2 * e - 1)) / 2, steps: ct };
    var g = Symbol.for("FluidValue.get");
    var b = Symbol.for("FluidValue.observers");
    var pt = (e) => Boolean(e && e[g]);
    var ue = (e) => e && e[g] ? e[g]() : e;
    var mt = (e) => e[b] || null;
    function Ce(e, t) {
      e.eventObserved ? e.eventObserved(t) : e(t);
    }
    function bt(e, t) {
      let r = e[b];
      r && r.forEach((n) => {
        Ce(n, t);
      });
    }
    var _a, _b, _c;
    var se = (_c = class {
      constructor(t) {
        __publicField(this, _a);
        __publicField(this, _b);
        if (!t && !(t = this.get))
          throw Error("Unknown getter");
        ze(this, t);
      }
    }, _a = g, _b = b, _c);
    var ze = (e, t) => Le(e, g, t);
    function xt(e, t) {
      if (e[g]) {
        let r = e[b];
        r || Le(e, b, r = /* @__PURE__ */ new Set()), r.has(t) || (r.add(t), e.observerAdded && e.observerAdded(r.size, t));
      }
      return t;
    }
    function ht(e, t) {
      let r = e[b];
      if (r && r.has(t)) {
        let n = r.size - 1;
        n ? r.delete(t) : e[b] = null, e.observerRemoved && e.observerRemoved(n, t);
      }
    }
    var Le = (e, t, r) => Object.defineProperty(e, t, { value: r, writable: true, configurable: true });
    var F = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var Ve = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
    var le = new RegExp(`(${F.source})(%|[a-z]+)`, "i");
    var Pe = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
    var x = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    var ce = (e) => {
      let [t, r] = yt(e);
      if (!t || m())
        return e;
      let n = window.getComputedStyle(document.documentElement).getPropertyValue(t);
      if (n)
        return n.trim();
      if (r && r.startsWith("--")) {
        let o = window.getComputedStyle(document.documentElement).getPropertyValue(r);
        return o || e;
      } else {
        if (r && x.test(r))
          return ce(r);
        if (r)
          return r;
      }
      return e;
    };
    var yt = (e) => {
      let t = x.exec(e);
      if (!t)
        return [,];
      let [, r, n] = t;
      return [r, n];
    };
    var de;
    var gt = (e, t, r, n, o) => `rgba(${Math.round(t)}, ${Math.round(r)}, ${Math.round(n)}, ${o})`;
    var vt = (e) => {
      de || (de = c ? new RegExp(`(${Object.keys(c).join("|")})(?!\\w)`, "g") : /^\b$/);
      let t = e.output.map((f) => ue(f).replace(x, ce).replace(Ve, P).replace(de, P)), r = t.map((f) => f.match(F).map(Number)), o = r[0].map((f, i) => r.map((s) => {
        if (!(i in s))
          throw Error('The arity of each "output" value must be equal');
        return s[i];
      })).map((f) => q({ ...e, output: f }));
      return (f) => {
        var _a2;
        let i = !le.test(t[0]) && ((_a2 = t.find((h) => le.test(h))) == null ? void 0 : _a2.replace(F, "")), s = 0;
        return t[0].replace(F, () => `${o[s++](f)}${i || ""}`).replace(Pe, gt);
      };
    };
    var U = "react-spring: ";
    var pe = (e) => {
      let t = e, r = false;
      if (typeof t != "function")
        throw new TypeError(`${U}once requires a function parameter`);
      return (...n) => {
        r || (t(...n), r = true);
      };
    };
    var Et = pe(console.warn);
    function Ot() {
      Et(`${U}The "interpolate" function is deprecated in v9 (use "to" instead)`);
    }
    var wt = pe(console.warn);
    function Tt() {
      wt(`${U}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
    }
    function Ft(e) {
      return u.str(e) && (e[0] == "#" || /\d/.test(e) || !m() && x.test(e) || e in (c || {}));
    }
    var xe = require_dist();
    var v;
    var H = /* @__PURE__ */ new WeakMap();
    var It = (e) => e.forEach(({ target: t, contentRect: r }) => {
      var _a2;
      return (_a2 = H.get(t)) == null ? void 0 : _a2.forEach((n) => n(r));
    });
    function qe(e, t) {
      v || typeof ResizeObserver < "u" && (v = new ResizeObserver(It));
      let r = H.get(t);
      return r || (r = /* @__PURE__ */ new Set(), H.set(t, r)), r.add(e), v && v.observe(t), () => {
        let n = H.get(t);
        !n || (n.delete(e), !n.size && v && v.unobserve(t));
      };
    }
    var B = /* @__PURE__ */ new Set();
    var I;
    var kt = () => {
      let e = () => {
        B.forEach((t) => t({ width: window.innerWidth, height: window.innerHeight }));
      };
      return window.addEventListener("resize", e), () => {
        window.removeEventListener("resize", e);
      };
    };
    var $e = (e) => (B.add(e), I || (I = kt()), () => {
      B.delete(e), !B.size && I && (I(), I = void 0);
    });
    var me = (e, { container: t = document.documentElement } = {}) => t === document.documentElement ? $e(e) : qe(e, t);
    var Ge = (e, t, r) => t - e === 0 ? 1 : (r - e) / (t - e);
    var St = { x: { length: "Width", position: "Left" }, y: { length: "Height", position: "Top" } };
    var j = class {
      constructor(t, r) {
        __publicField(this, "callback");
        __publicField(this, "container");
        __publicField(this, "info");
        __publicField(this, "createAxis", () => ({ current: 0, progress: 0, scrollLength: 0 }));
        __publicField(this, "updateAxis", (t) => {
          let r = this.info[t], { length: n, position: o } = St[t];
          r.current = this.container[`scroll${o}`], r.scrollLength = this.container["scroll" + n] - this.container["client" + n], r.progress = Ge(0, r.scrollLength, r.current);
        });
        __publicField(this, "update", () => {
          this.updateAxis("x"), this.updateAxis("y");
        });
        __publicField(this, "sendEvent", () => {
          this.callback(this.info);
        });
        __publicField(this, "advance", () => {
          this.update(), this.sendEvent();
        });
        this.callback = t, this.container = r, this.info = { time: 0, x: this.createAxis(), y: this.createAxis() };
      }
    };
    var k = /* @__PURE__ */ new WeakMap();
    var Qe = /* @__PURE__ */ new WeakMap();
    var be = /* @__PURE__ */ new WeakMap();
    var Ue = (e) => e === document.documentElement ? window : e;
    var Rt = (e, { container: t = document.documentElement } = {}) => {
      let r = be.get(t);
      r || (r = /* @__PURE__ */ new Set(), be.set(t, r));
      let n = new j(e, t);
      if (r.add(n), !k.has(t)) {
        let f = () => (r == null ? void 0 : r.forEach((s) => s.advance()), true);
        k.set(t, f);
        let i = Ue(t);
        window.addEventListener("resize", f, { passive: true }), t !== document.documentElement && Qe.set(t, me(f, { container: t })), i.addEventListener("scroll", f, { passive: true });
      }
      let o = k.get(t);
      return (0, xe.raf)(o), () => {
        var _a2;
        xe.raf.cancel(o);
        let f = be.get(t);
        if (!f || (f.delete(n), f.size))
          return;
        let i = k.get(t);
        k.delete(t), i && (Ue(t).removeEventListener("scroll", i), window.removeEventListener("resize", i), (_a2 = Qe.get(t)) == null ? void 0 : _a2());
      };
    };
    var He = require_react();
    function At(e) {
      let t = (0, He.useRef)(null);
      return t.current === null && (t.current = e()), t.current;
    }
    var De = require_react();
    var Be = require_react();
    var D = require_react();
    var S = m() ? D.useEffect : D.useLayoutEffect;
    var je = () => {
      let e = (0, Be.useRef)(false);
      return S(() => (e.current = true, () => {
        e.current = false;
      }), []), e;
    };
    function Mt() {
      let e = (0, De.useState)()[1], t = je();
      return () => {
        t.current && e(Math.random());
      };
    }
    var E = require_react();
    function Ct(e, t) {
      let [r] = (0, E.useState)(() => ({ inputs: t, result: e() })), n = (0, E.useRef)(), o = n.current, f = o;
      return f ? Boolean(t && f.inputs && zt(t, f.inputs)) || (f = { inputs: t, result: e() }) : f = r, (0, E.useEffect)(() => {
        n.current = f, o == r && (r.inputs = r.result = void 0);
      }, [f]), f.result;
    }
    function zt(e, t) {
      if (e.length !== t.length)
        return false;
      for (let r = 0; r < e.length; r++)
        if (e[r] !== t[r])
          return false;
      return true;
    }
    var We = require_react();
    var Lt = (e) => (0, We.useEffect)(e, Vt);
    var Vt = [];
    var W = require_react();
    function Pt(e) {
      let t = (0, W.useRef)();
      return (0, W.useEffect)(() => {
        t.current = e;
      }), t.current;
    }
    var Ke = require_react();
    var qt = () => {
      let [e, t] = (0, Ke.useState)(null);
      return S(() => {
        let r = window.matchMedia("(prefers-reduced-motion)"), n = (o) => {
          t(o.matches), _({ skipAnimation: o.matches });
        };
        return n(r), r.addEventListener("change", n), () => {
          r.removeEventListener("change", n);
        };
      }, []), e;
    };
    var Ne = require_dist();
  }
});

// node_modules/@react-spring/animated/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@react-spring/animated/dist/index.js"(exports, module) {
    "use strict";
    var D = Object.create;
    var T = Object.defineProperty;
    var K = Object.getOwnPropertyDescriptor;
    var M = Object.getOwnPropertyNames;
    var q = Object.getPrototypeOf;
    var z = Object.prototype.hasOwnProperty;
    var G = (e, t) => {
      for (var r in t)
        T(e, r, { get: t[r], enumerable: true });
    };
    var E = (e, t, r, a2) => {
      if (t && typeof t == "object" || typeof t == "function")
        for (let n of M(t))
          !z.call(e, n) && n !== r && T(e, n, { get: () => t[n], enumerable: !(a2 = K(t, n)) || a2.enumerable });
      return e;
    };
    var J = (e, t, r) => (r = e != null ? D(q(e)) : {}, E(t || !e || !e.__esModule ? T(r, "default", { value: e, enumerable: true }) : r, e));
    var Q = (e) => E(T({}, "__esModule", { value: true }), e);
    var re = {};
    G(re, { Animated: () => h, AnimatedArray: () => g, AnimatedObject: () => p, AnimatedString: () => m, AnimatedValue: () => d, createHost: () => te, getAnimated: () => v, getAnimatedType: () => Y, getPayload: () => k, isAnimated: () => S, setAnimated: () => N });
    module.exports = Q(re);
    var O = require_dist2();
    var b = Symbol.for("Animated:node");
    var S = (e) => !!e && e[b] === e;
    var v = (e) => e && e[b];
    var N = (e, t) => (0, O.defineHidden)(e, b, t);
    var k = (e) => e && e[b] && e[b].getPayload();
    var h = class {
      constructor() {
        __publicField(this, "payload");
        N(this, this);
      }
      getPayload() {
        return this.payload || [];
      }
    };
    var P = require_dist2();
    var d = class extends h {
      constructor(r) {
        super();
        __publicField(this, "done", true);
        __publicField(this, "elapsedTime");
        __publicField(this, "lastPosition");
        __publicField(this, "lastVelocity");
        __publicField(this, "v0");
        __publicField(this, "durationProgress", 0);
        this._value = r;
        P.is.num(this._value) && (this.lastPosition = this._value);
      }
      static create(r) {
        return new d(r);
      }
      getPayload() {
        return [this];
      }
      getValue() {
        return this._value;
      }
      setValue(r, a2) {
        return P.is.num(r) && (this.lastPosition = r, a2 && (r = Math.round(r / a2) * a2, this.done && (this.lastPosition = r))), this._value === r ? false : (this._value = r, true);
      }
      reset() {
        let { done: r } = this;
        this.done = false, P.is.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, r && (this.lastVelocity = null), this.v0 = null);
      }
    };
    var x = require_dist2();
    var m = class extends d {
      constructor(t) {
        super(0);
        __publicField(this, "_string", null);
        __publicField(this, "_toString");
        this._toString = (0, x.createInterpolator)({ output: [t, t] });
      }
      static create(t) {
        return new m(t);
      }
      getValue() {
        let t = this._string;
        return t ?? (this._string = this._toString(this._value));
      }
      setValue(t) {
        if (x.is.str(t)) {
          if (t == this._string)
            return false;
          this._string = t, this._value = 1;
        } else if (super.setValue(t))
          this._string = null;
        else
          return false;
        return true;
      }
      reset(t) {
        t && (this._toString = (0, x.createInterpolator)({ output: [this.getValue(), t] })), this._value = 0, super.reset();
      }
    };
    var U = require_dist2();
    var u = require_dist2();
    var V = { dependencies: null };
    var p = class extends h {
      constructor(r) {
        super();
        this.source = r;
        this.setValue(r);
      }
      getValue(r) {
        let a2 = {};
        return (0, u.eachProp)(this.source, (n, s) => {
          S(n) ? a2[s] = n.getValue(r) : (0, u.hasFluidValue)(n) ? a2[s] = (0, u.getFluidValue)(n) : r || (a2[s] = n);
        }), a2;
      }
      setValue(r) {
        this.source = r, this.payload = this._makePayload(r);
      }
      reset() {
        this.payload && (0, u.each)(this.payload, (r) => r.reset());
      }
      _makePayload(r) {
        if (r) {
          let a2 = /* @__PURE__ */ new Set();
          return (0, u.eachProp)(r, this._addToPayload, a2), Array.from(a2);
        }
      }
      _addToPayload(r) {
        V.dependencies && (0, u.hasFluidValue)(r) && V.dependencies.add(r);
        let a2 = k(r);
        a2 && (0, u.each)(a2, (n) => this.add(n));
      }
    };
    var g = class extends p {
      constructor(t) {
        super(t);
      }
      static create(t) {
        return new g(t);
      }
      getValue() {
        return this.source.map((t) => t.getValue());
      }
      setValue(t) {
        let r = this.getPayload();
        return t.length == r.length ? r.map((a2, n) => a2.setValue(t[n])).some(Boolean) : (super.setValue(t.map(X)), true);
      }
    };
    function X(e) {
      return ((0, U.isAnimatedString)(e) ? m : d).create(e);
    }
    var _ = require_dist2();
    function Y(e) {
      let t = v(e);
      return t ? t.constructor : _.is.arr(e) ? g : (0, _.isAnimatedString)(e) ? m : d;
    }
    var f = require_dist2();
    var j = J(require_react());
    var c = require_react();
    var o = require_dist2();
    var R = (e, t) => {
      let r = !o.is.fun(e) || e.prototype && e.prototype.isReactComponent;
      return (0, c.forwardRef)((a2, n) => {
        let s = (0, c.useRef)(null), i = r && (0, c.useCallback)((l) => {
          s.current = ee(n, l);
        }, [n]), [y, L] = Z(a2, t), $ = (0, o.useForceUpdate)(), w = () => {
          let l = s.current;
          if (r && !l)
            return;
          (l ? t.applyAnimatedValues(l, y.getValue(true)) : false) === false && $();
        }, C = new F(w, L), A = (0, c.useRef)();
        (0, o.useIsomorphicLayoutEffect)(() => (A.current = C, (0, o.each)(L, (l) => (0, o.addFluidObserver)(l, C)), () => {
          A.current && ((0, o.each)(A.current.deps, (l) => (0, o.removeFluidObserver)(l, A.current)), o.raf.cancel(A.current.update));
        })), (0, c.useEffect)(w, []), (0, o.useOnce)(() => () => {
          let l = A.current;
          (0, o.each)(l.deps, (H) => (0, o.removeFluidObserver)(H, l));
        });
        let B = t.getComponentProps(y.getValue());
        return j.createElement(e, { ...B, ref: i });
      });
    };
    var F = class {
      constructor(t, r) {
        this.update = t;
        this.deps = r;
      }
      eventObserved(t) {
        t.type == "change" && o.raf.write(this.update);
      }
    };
    function Z(e, t) {
      let r = /* @__PURE__ */ new Set();
      return V.dependencies = r, e.style && (e = { ...e, style: t.createAnimatedStyle(e.style) }), e = new p(e), V.dependencies = null, [e, r];
    }
    function ee(e, t) {
      return e && (o.is.fun(e) ? e(t) : e.current = t), t;
    }
    var I = Symbol.for("AnimatedComponent");
    var te = (e, { applyAnimatedValues: t = () => false, createAnimatedStyle: r = (n) => new p(n), getComponentProps: a2 = (n) => n } = {}) => {
      let n = { applyAnimatedValues: t, createAnimatedStyle: r, getComponentProps: a2 }, s = (i) => {
        let y = W(i) || "Anonymous";
        return f.is.str(i) ? i = s[i] || (s[i] = R(i, n)) : i = i[I] || (i[I] = R(i, n)), i.displayName = `Animated(${y})`, i;
      };
      return (0, f.eachProp)(e, (i, y) => {
        f.is.arr(e) && (y = W(i)), s[y] = s(i);
      }), { animated: s };
    };
    var W = (e) => f.is.str(e) ? e : e && f.is.str(e.displayName) ? e.displayName : f.is.fun(e) && e.name || null;
  }
});

// node_modules/@react-spring/types/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@react-spring/types/dist/index.js"(exports, module) {
    "use strict";
    var r = Object.defineProperty;
    var T = Object.getOwnPropertyDescriptor;
    var a2 = Object.getOwnPropertyNames;
    var s = Object.prototype.hasOwnProperty;
    var x = (t, e) => {
      for (var o in e)
        r(t, o, { get: e[o], enumerable: true });
    };
    var i = (t, e, o, y) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let n of a2(e))
          !s.call(t, n) && n !== o && r(t, n, { get: () => e[n], enumerable: !(y = T(e, n)) || y.enumerable });
      return t;
    };
    var f = (t) => i(r({}, "__esModule", { value: true }), t);
    var d = {};
    x(d, { Any: () => p });
    module.exports = f(d);
    var p = class {
      constructor() {
        __publicField(this, "_");
      }
    };
  }
});

// node_modules/@react-spring/core/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@react-spring/core/dist/index.js"(exports, module) {
    "use strict";
    var qt = Object.create;
    var ze = Object.defineProperty;
    var Qt = Object.getOwnPropertyDescriptor;
    var zt = Object.getOwnPropertyNames;
    var Gt = Object.getPrototypeOf;
    var Bt = Object.prototype.hasOwnProperty;
    var Kt = (t, e) => {
      for (var n in e)
        ze(t, n, { get: e[n], enumerable: true });
    };
    var Qe = (t, e, n, r) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let o of zt(e))
          !Bt.call(t, o) && o !== n && ze(t, o, { get: () => e[o], enumerable: !(r = Qt(e, o)) || r.enumerable });
      return t;
    };
    var L = (t, e, n) => (Qe(t, e, "default"), n && Qe(n, e, "default"));
    var Pt = (t, e, n) => (n = t != null ? qt(Gt(t)) : {}, Qe(e || !t || !t.__esModule ? ze(n, "default", { value: t, enumerable: true }) : n, t));
    var Xt = (t) => Qe(ze({}, "__esModule", { value: true }), t);
    var U = {};
    Kt(U, { BailSignal: () => Ce, Controller: () => pe, FrameValue: () => te, Globals: () => Ae.Globals, Interpolation: () => se, Spring: () => mn, SpringContext: () => re, SpringRef: () => le, SpringValue: () => ue, Trail: () => hn, Transition: () => gn, config: () => it, createInterpolator: () => fe.createInterpolator, easings: () => fe.easings, inferTo: () => Se, interpolate: () => Pn, to: () => Sn, update: () => Tn, useChain: () => $t, useInView: () => dn, useIsomorphicLayoutEffect: () => fe.useIsomorphicLayoutEffect, useReducedMotion: () => fe.useReducedMotion, useResize: () => cn, useScroll: () => ln, useSpring: () => oe, useSpringRef: () => sn, useSpringValue: () => an, useSprings: () => je, useTrail: () => ht, useTransition: () => gt });
    module.exports = Xt(U);
    var Z = require_dist2();
    var V = require_dist2();
    function k(t, ...e) {
      return V.is.fun(t) ? t(...e) : t;
    }
    var ge = (t, e) => t === true || !!(e && t && (V.is.fun(t) ? t(e) : (0, V.toArray)(t).includes(e)));
    var st = (t, e) => V.is.obj(t) ? e && t[e] : t;
    var Ge = (t, e) => t.default === true ? t[e] : t.default ? t.default[e] : void 0;
    var Yt = (t) => t;
    var ye = (t, e = Yt) => {
      let n = Ht;
      t.default && t.default !== true && (t = t.default, n = Object.keys(t));
      let r = {};
      for (let o of n) {
        let s = e(t[o], o);
        V.is.und(s) || (r[o] = s);
      }
      return r;
    };
    var Ht = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
    var Jt = { config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1 };
    function Wt(t) {
      let e = {}, n = 0;
      if ((0, V.eachProp)(t, (r, o) => {
        Jt[o] || (e[o] = r, n++);
      }), n)
        return e;
    }
    function Se(t) {
      let e = Wt(t);
      if (e) {
        let n = { to: e };
        return (0, V.eachProp)(t, (r, o) => o in e || (n[o] = r)), n;
      }
      return { ...t };
    }
    function Re(t) {
      return t = (0, V.getFluidValue)(t), V.is.arr(t) ? t.map(Re) : (0, V.isAnimatedString)(t) ? V.Globals.createStringInterpolator({ range: [0, 1], output: [t, t] })(1) : t;
    }
    function Be(t) {
      for (let e in t)
        return true;
      return false;
    }
    function Ke(t) {
      return V.is.fun(t) || V.is.arr(t) && V.is.obj(t[0]);
    }
    function ke(t, e) {
      var _a;
      (_a = t.ref) == null ? void 0 : _a.delete(t), e == null ? void 0 : e.delete(t);
    }
    function ve(t, e) {
      var _a;
      e && t.ref !== e && ((_a = t.ref) == null ? void 0 : _a.delete(t), e.add(t), t.ref = e);
    }
    function $t(t, e, n = 1e3) {
      (0, Z.useIsomorphicLayoutEffect)(() => {
        if (e) {
          let r = 0;
          (0, Z.each)(t, (o, s) => {
            let u = o.current;
            if (u.length) {
              let a2 = n * e[s];
              isNaN(a2) ? a2 = r : r = a2, (0, Z.each)(u, (p) => {
                (0, Z.each)(p.queue, (l) => {
                  let d = l.delay;
                  l.delay = (m) => a2 + k(d || 0, m);
                });
              }), o.start();
            }
          });
        } else {
          let r = Promise.resolve();
          (0, Z.each)(t, (o) => {
            let s = o.current;
            if (s.length) {
              let u = s.map((a2) => {
                let p = a2.queue;
                return a2.queue = [], p;
              });
              r = r.then(() => ((0, Z.each)(s, (a2, p) => (0, Z.each)(u[p] || [], (l) => a2.queue.push(l))), Promise.all(o.start())));
            }
          });
        }
      });
    }
    var Et = require_dist2();
    var J = require_react();
    var j = require_dist2();
    var i = require_dist2();
    var _ = require_dist3();
    var H = require_dist2();
    var it = { default: { tension: 170, friction: 26 }, gentle: { tension: 120, friction: 14 }, wobbly: { tension: 180, friction: 12 }, stiff: { tension: 210, friction: 20 }, slow: { tension: 280, friction: 60 }, molasses: { tension: 280, friction: 120 } };
    var at = { ...it.default, mass: 1, damping: 1, easing: H.easings.linear, clamp: false };
    var Xe = class {
      constructor() {
        __publicField(this, "tension");
        __publicField(this, "friction");
        __publicField(this, "frequency");
        __publicField(this, "damping");
        __publicField(this, "mass");
        __publicField(this, "velocity", 0);
        __publicField(this, "restVelocity");
        __publicField(this, "precision");
        __publicField(this, "progress");
        __publicField(this, "duration");
        __publicField(this, "easing");
        __publicField(this, "clamp");
        __publicField(this, "bounce");
        __publicField(this, "decay");
        __publicField(this, "round");
        Object.assign(this, at);
      }
    };
    function xt(t, e, n) {
      n && (n = { ...n }, Tt(n, e), e = { ...n, ...e }), Tt(t, e), Object.assign(t, e);
      for (let u in at)
        t[u] == null && (t[u] = at[u]);
      let { mass: r, frequency: o, damping: s } = t;
      return H.is.und(o) || (o < 0.01 && (o = 0.01), s < 0 && (s = 0), t.tension = Math.pow(2 * Math.PI / o, 2) * r, t.friction = 4 * Math.PI * s * r / o), t;
    }
    function Tt(t, e) {
      if (!H.is.und(e.decay))
        t.duration = void 0;
      else {
        let n = !H.is.und(e.tension) || !H.is.und(e.friction);
        (n || !H.is.und(e.frequency) || !H.is.und(e.damping) || !H.is.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0);
      }
    }
    var bt = [];
    var Ye = class {
      constructor() {
        __publicField(this, "changed", false);
        __publicField(this, "values", bt);
        __publicField(this, "toValues", null);
        __publicField(this, "fromValues", bt);
        __publicField(this, "to");
        __publicField(this, "from");
        __publicField(this, "config", new Xe());
        __publicField(this, "immediate", false);
      }
    };
    var Pe = require_dist2();
    function He(t, { key: e, props: n, defaultProps: r, state: o, actions: s }) {
      return new Promise((u, a2) => {
        let p, l, d = ge(n.cancel ?? (r == null ? void 0 : r.cancel), e);
        if (d)
          v();
        else {
          Pe.is.und(n.pause) || (o.paused = ge(n.pause, e));
          let f = r == null ? void 0 : r.pause;
          f !== true && (f = o.paused || ge(f, e)), p = k(n.delay || 0, e), f ? (o.resumeQueue.add(h), s.pause()) : (s.resume(), h());
        }
        function m() {
          o.resumeQueue.add(h), o.timeouts.delete(l), l.cancel(), p = l.time - Pe.raf.now();
        }
        function h() {
          p > 0 && !Pe.Globals.skipAnimation ? (o.delayed = true, l = Pe.raf.setTimeout(v, p), o.pauseQueue.add(m), o.timeouts.add(l)) : v();
        }
        function v() {
          o.delayed && (o.delayed = false), o.pauseQueue.delete(m), o.timeouts.delete(l), t <= (o.cancelId || 0) && (d = true);
          try {
            s.start({ ...n, callId: t, cancel: d }, u);
          } catch (f) {
            a2(f);
          }
        }
      });
    }
    var Q = require_dist2();
    var Ue = (t, e) => e.length == 1 ? e[0] : e.some((n) => n.cancelled) ? ee(t.get()) : e.every((n) => n.noop) ? ut(t.get()) : G(t.get(), e.every((n) => n.finished));
    var ut = (t) => ({ value: t, noop: true, finished: true, cancelled: false });
    var G = (t, e, n = false) => ({ value: t, finished: e, cancelled: n });
    var ee = (t) => ({ value: t, cancelled: true, finished: false });
    function We(t, e, n, r) {
      let { callId: o, parentId: s, onRest: u } = e, { asyncTo: a2, promise: p } = n;
      return !s && t === a2 && !e.reset ? p : n.promise = (async () => {
        n.asyncId = o, n.asyncTo = t;
        let l = ye(e, (c, g) => g === "onRest" ? void 0 : c), d, m, h = new Promise((c, g) => (d = c, m = g)), v = (c) => {
          let g = o <= (n.cancelId || 0) && ee(r) || o !== n.asyncId && G(r, false);
          if (g)
            throw c.result = g, m(c), c;
        }, f = (c, g) => {
          let y = new Ce(), A = new Je();
          return (async () => {
            if (Q.Globals.skipAnimation)
              throw Te(n), A.result = G(r, false), m(A), A;
            v(y);
            let P = Q.is.obj(c) ? { ...c } : { ...g, to: c };
            P.parentId = o, (0, Q.eachProp)(l, (E, w) => {
              Q.is.und(P[w]) && (P[w] = E);
            });
            let I = await r.start(P);
            return v(y), n.paused && await new Promise((E) => {
              n.resumeQueue.add(E);
            }), I;
          })();
        }, T;
        if (Q.Globals.skipAnimation)
          return Te(n), G(r, false);
        try {
          let c;
          Q.is.arr(t) ? c = (async (g) => {
            for (let y of g)
              await f(y);
          })(t) : c = Promise.resolve(t(f, r.stop.bind(r))), await Promise.all([c.then(d), h]), T = G(r.get(), true, false);
        } catch (c) {
          if (c instanceof Ce)
            T = c.result;
          else if (c instanceof Je)
            T = c.result;
          else
            throw c;
        } finally {
          o == n.asyncId && (n.asyncId = s, n.asyncTo = s ? a2 : void 0, n.promise = s ? p : void 0);
        }
        return Q.is.fun(u) && Q.raf.batchedUpdates(() => {
          u(T, r, r.item);
        }), T;
      })();
    }
    function Te(t, e) {
      (0, Q.flush)(t.timeouts, (n) => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e);
    }
    var Ce = class extends Error {
      constructor() {
        super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
        __publicField(this, "result");
      }
    };
    var Je = class extends Error {
      constructor() {
        super("SkipAnimationSignal");
        __publicField(this, "result");
      }
    };
    var X = require_dist2();
    var At = require_dist3();
    var Ee = (t) => t instanceof te;
    var Zt = 1;
    var te = class extends X.FluidValue {
      constructor() {
        super(...arguments);
        __publicField(this, "id", Zt++);
        __publicField(this, "_priority", 0);
      }
      get priority() {
        return this._priority;
      }
      set priority(e) {
        this._priority != e && (this._priority = e, this._onPriorityChange(e));
      }
      get() {
        let e = (0, At.getAnimated)(this);
        return e && e.getValue();
      }
      to(...e) {
        return X.Globals.to(this, e);
      }
      interpolate(...e) {
        return (0, X.deprecateInterpolate)(), X.Globals.to(this, e);
      }
      toJSON() {
        return this.get();
      }
      observerAdded(e) {
        e == 1 && this._attach();
      }
      observerRemoved(e) {
        e == 0 && this._detach();
      }
      _attach() {
      }
      _detach() {
      }
      _onChange(e, n = false) {
        (0, X.callFluidObservers)(this, { type: "change", parent: this, value: e, idle: n });
      }
      _onPriorityChange(e) {
        this.idle || X.frameLoop.sort(this), (0, X.callFluidObservers)(this, { type: "priority", parent: this, priority: e });
      }
    };
    var xe = Symbol.for("SpringPhase");
    var Rt = 1;
    var pt = 2;
    var lt = 4;
    var $e = (t) => (t[xe] & Rt) > 0;
    var ne = (t) => (t[xe] & pt) > 0;
    var Ie = (t) => (t[xe] & lt) > 0;
    var ct = (t, e) => e ? t[xe] |= pt | Rt : t[xe] &= ~pt;
    var ft = (t, e) => e ? t[xe] |= lt : t[xe] &= ~lt;
    var ue = class extends te {
      constructor(e, n) {
        super();
        __publicField(this, "key");
        __publicField(this, "animation", new Ye());
        __publicField(this, "queue");
        __publicField(this, "defaultProps", {});
        __publicField(this, "_state", { paused: false, delayed: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() });
        __publicField(this, "_pendingCalls", /* @__PURE__ */ new Set());
        __publicField(this, "_lastCallId", 0);
        __publicField(this, "_lastToId", 0);
        __publicField(this, "_memoizedDuration", 0);
        if (!i.is.und(e) || !i.is.und(n)) {
          let r = i.is.obj(e) ? { ...e } : { ...n, from: e };
          i.is.und(r.default) && (r.default = true), this.start(r);
        }
      }
      get idle() {
        return !(ne(this) || this._state.asyncTo) || Ie(this);
      }
      get goal() {
        return (0, i.getFluidValue)(this.animation.to);
      }
      get velocity() {
        let e = (0, _.getAnimated)(this);
        return e instanceof _.AnimatedValue ? e.lastVelocity || 0 : e.getPayload().map((n) => n.lastVelocity || 0);
      }
      get hasAnimated() {
        return $e(this);
      }
      get isAnimating() {
        return ne(this);
      }
      get isPaused() {
        return Ie(this);
      }
      get isDelayed() {
        return this._state.delayed;
      }
      advance(e) {
        let n = true, r = false, o = this.animation, { config: s, toValues: u } = o, a2 = (0, _.getPayload)(o.to);
        !a2 && (0, i.hasFluidValue)(o.to) && (u = (0, i.toArray)((0, i.getFluidValue)(o.to))), o.values.forEach((d, m) => {
          if (d.done)
            return;
          let h = d.constructor == _.AnimatedString ? 1 : a2 ? a2[m].lastPosition : u[m], v = o.immediate, f = h;
          if (!v) {
            if (f = d.lastPosition, s.tension <= 0) {
              d.done = true;
              return;
            }
            let T = d.elapsedTime += e, c = o.fromValues[m], g = d.v0 != null ? d.v0 : d.v0 = i.is.arr(s.velocity) ? s.velocity[m] : s.velocity, y, A = s.precision || (c == h ? 5e-3 : Math.min(1, Math.abs(h - c) * 1e-3));
            if (i.is.und(s.duration))
              if (s.decay) {
                let P = s.decay === true ? 0.998 : s.decay, I = Math.exp(-(1 - P) * T);
                f = c + g / (1 - P) * (1 - I), v = Math.abs(d.lastPosition - f) <= A, y = g * I;
              } else {
                y = d.lastVelocity == null ? g : d.lastVelocity;
                let P = s.restVelocity || A / 10, I = s.clamp ? 0 : s.bounce, E = !i.is.und(I), w = c == h ? d.v0 > 0 : c < h, O, B = false, F = 1, de = Math.ceil(e / F);
                for (let K = 0; K < de && (O = Math.abs(y) > P, !(!O && (v = Math.abs(h - f) <= A, v))); ++K) {
                  E && (B = f == h || f > h == w, B && (y = -y * I, f = h));
                  let W = -s.tension * 1e-6 * (f - h), S = -s.friction * 1e-3 * y, b = (W + S) / s.mass;
                  y = y + b * F, f = f + y * F;
                }
              }
            else {
              let P = 1;
              s.duration > 0 && (this._memoizedDuration !== s.duration && (this._memoizedDuration = s.duration, d.durationProgress > 0 && (d.elapsedTime = s.duration * d.durationProgress, T = d.elapsedTime += e)), P = (s.progress || 0) + T / this._memoizedDuration, P = P > 1 ? 1 : P < 0 ? 0 : P, d.durationProgress = P), f = c + s.easing(P) * (h - c), y = (f - d.lastPosition) / e, v = P == 1;
            }
            d.lastVelocity = y, Number.isNaN(f) && (console.warn("Got NaN while animating:", this), v = true);
          }
          a2 && !a2[m].done && (v = false), v ? d.done = true : n = false, d.setValue(f, s.round) && (r = true);
        });
        let p = (0, _.getAnimated)(this), l = p.getValue();
        if (n) {
          let d = (0, i.getFluidValue)(o.to);
          (l !== d || r) && !s.decay ? (p.setValue(d), this._onChange(d)) : r && s.decay && this._onChange(l), this._stop();
        } else
          r && this._onChange(l);
      }
      set(e) {
        return i.raf.batchedUpdates(() => {
          this._stop(), this._focus(e), this._set(e);
        }), this;
      }
      pause() {
        this._update({ pause: true });
      }
      resume() {
        this._update({ pause: false });
      }
      finish() {
        if (ne(this)) {
          let { to: e, config: n } = this.animation;
          i.raf.batchedUpdates(() => {
            this._onStart(), n.decay || this._set(e, false), this._stop();
          });
        }
        return this;
      }
      update(e) {
        return (this.queue || (this.queue = [])).push(e), this;
      }
      start(e, n) {
        let r;
        return i.is.und(e) ? (r = this.queue || [], this.queue = []) : r = [i.is.obj(e) ? e : { ...n, to: e }], Promise.all(r.map((o) => this._update(o))).then((o) => Ue(this, o));
      }
      stop(e) {
        let { to: n } = this.animation;
        return this._focus(this.get()), Te(this._state, e && this._lastCallId), i.raf.batchedUpdates(() => this._stop(n, e)), this;
      }
      reset() {
        this._update({ reset: true });
      }
      eventObserved(e) {
        e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
      }
      _prepareNode(e) {
        let n = this.key || "", { to: r, from: o } = e;
        r = i.is.obj(r) ? r[n] : r, (r == null || Ke(r)) && (r = void 0), o = i.is.obj(o) ? o[n] : o, o == null && (o = void 0);
        let s = { to: r, from: o };
        return $e(this) || (e.reverse && ([r, o] = [o, r]), o = (0, i.getFluidValue)(o), i.is.und(o) ? (0, _.getAnimated)(this) || this._set(r) : this._set(o)), s;
      }
      _update({ ...e }, n) {
        let { key: r, defaultProps: o } = this;
        e.default && Object.assign(o, ye(e, (a2, p) => /^on/.test(p) ? st(a2, r) : a2)), Ct(this, e, "onProps"), Le(this, "onProps", e, this);
        let s = this._prepareNode(e);
        if (Object.isFrozen(this))
          throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
        let u = this._state;
        return He(++this._lastCallId, { key: r, props: e, defaultProps: o, state: u, actions: { pause: () => {
          Ie(this) || (ft(this, true), (0, i.flushCalls)(u.pauseQueue), Le(this, "onPause", G(this, we(this, this.animation.to)), this));
        }, resume: () => {
          Ie(this) && (ft(this, false), ne(this) && this._resume(), (0, i.flushCalls)(u.resumeQueue), Le(this, "onResume", G(this, we(this, this.animation.to)), this));
        }, start: this._merge.bind(this, s) } }).then((a2) => {
          if (e.loop && a2.finished && !(n && a2.noop)) {
            let p = dt(e);
            if (p)
              return this._update(p, true);
          }
          return a2;
        });
      }
      _merge(e, n, r) {
        if (n.cancel)
          return this.stop(true), r(ee(this));
        let o = !i.is.und(e.to), s = !i.is.und(e.from);
        if (o || s)
          if (n.callId > this._lastToId)
            this._lastToId = n.callId;
          else
            return r(ee(this));
        let { key: u, defaultProps: a2, animation: p } = this, { to: l, from: d } = p, { to: m = l, from: h = d } = e;
        s && !o && (!n.default || i.is.und(m)) && (m = h), n.reverse && ([m, h] = [h, m]);
        let v = !(0, i.isEqual)(h, d);
        v && (p.from = h), h = (0, i.getFluidValue)(h);
        let f = !(0, i.isEqual)(m, l);
        f && this._focus(m);
        let T = Ke(n.to), { config: c } = p, { decay: g, velocity: y } = c;
        (o || s) && (c.velocity = 0), n.config && !T && xt(c, k(n.config, u), n.config !== a2.config ? k(a2.config, u) : void 0);
        let A = (0, _.getAnimated)(this);
        if (!A || i.is.und(m))
          return r(G(this, true));
        let P = i.is.und(n.reset) ? s && !n.default : !i.is.und(h) && ge(n.reset, u), I = P ? h : this.get(), E = Re(m), w = i.is.num(E) || i.is.arr(E) || (0, i.isAnimatedString)(E), O = !T && (!w || ge(a2.immediate || n.immediate, u));
        if (f) {
          let K = (0, _.getAnimatedType)(m);
          if (K !== A.constructor)
            if (O)
              A = this._set(E);
            else
              throw Error(`Cannot animate between ${A.constructor.name} and ${K.name}, as the "to" prop suggests`);
        }
        let B = A.constructor, F = (0, i.hasFluidValue)(m), de = false;
        if (!F) {
          let K = P || !$e(this) && v;
          (f || K) && (de = (0, i.isEqual)(Re(I), E), F = !de), (!(0, i.isEqual)(p.immediate, O) && !O || !(0, i.isEqual)(c.decay, g) || !(0, i.isEqual)(c.velocity, y)) && (F = true);
        }
        if (de && ne(this) && (p.changed && !P ? F = true : F || this._stop(l)), !T && ((F || (0, i.hasFluidValue)(l)) && (p.values = A.getPayload(), p.toValues = (0, i.hasFluidValue)(m) ? null : B == _.AnimatedString ? [1] : (0, i.toArray)(E)), p.immediate != O && (p.immediate = O, !O && !P && this._set(l)), F)) {
          let { onRest: K } = p;
          (0, i.each)(en, (S) => Ct(this, n, S));
          let W = G(this, we(this, l));
          (0, i.flushCalls)(this._pendingCalls, W), this._pendingCalls.add(r), p.changed && i.raf.batchedUpdates(() => {
            var _a;
            p.changed = !P, K == null ? void 0 : K(W, this), P ? k(a2.onRest, W) : (_a = p.onStart) == null ? void 0 : _a.call(p, W, this);
          });
        }
        P && this._set(I), T ? r(We(n.to, n, this._state, this)) : F ? this._start() : ne(this) && !f ? this._pendingCalls.add(r) : r(ut(I));
      }
      _focus(e) {
        let n = this.animation;
        e !== n.to && ((0, i.getFluidObservers)(this) && this._detach(), n.to = e, (0, i.getFluidObservers)(this) && this._attach());
      }
      _attach() {
        let e = 0, { to: n } = this.animation;
        (0, i.hasFluidValue)(n) && ((0, i.addFluidObserver)(n, this), Ee(n) && (e = n.priority + 1)), this.priority = e;
      }
      _detach() {
        let { to: e } = this.animation;
        (0, i.hasFluidValue)(e) && (0, i.removeFluidObserver)(e, this);
      }
      _set(e, n = true) {
        let r = (0, i.getFluidValue)(e);
        if (!i.is.und(r)) {
          let o = (0, _.getAnimated)(this);
          if (!o || !(0, i.isEqual)(r, o.getValue())) {
            let s = (0, _.getAnimatedType)(r);
            !o || o.constructor != s ? (0, _.setAnimated)(this, s.create(r)) : o.setValue(r), o && i.raf.batchedUpdates(() => {
              this._onChange(r, n);
            });
          }
        }
        return (0, _.getAnimated)(this);
      }
      _onStart() {
        let e = this.animation;
        e.changed || (e.changed = true, Le(this, "onStart", G(this, we(this, e.to)), this));
      }
      _onChange(e, n) {
        n || (this._onStart(), k(this.animation.onChange, e, this)), k(this.defaultProps.onChange, e, this), super._onChange(e, n);
      }
      _start() {
        let e = this.animation;
        (0, _.getAnimated)(this).reset((0, i.getFluidValue)(e.to)), e.immediate || (e.fromValues = e.values.map((n) => n.lastPosition)), ne(this) || (ct(this, true), Ie(this) || this._resume());
      }
      _resume() {
        i.Globals.skipAnimation ? this.finish() : i.frameLoop.start(this);
      }
      _stop(e, n) {
        if (ne(this)) {
          ct(this, false);
          let r = this.animation;
          (0, i.each)(r.values, (s) => {
            s.done = true;
          }), r.toValues && (r.onChange = r.onPause = r.onResume = void 0), (0, i.callFluidObservers)(this, { type: "idle", parent: this });
          let o = n ? ee(this.get()) : G(this.get(), we(this, e ?? r.to));
          (0, i.flushCalls)(this._pendingCalls, o), r.changed && (r.changed = false, Le(this, "onRest", o, this));
        }
      }
    };
    function we(t, e) {
      let n = Re(e), r = Re(t.get());
      return (0, i.isEqual)(r, n);
    }
    function dt(t, e = t.loop, n = t.to) {
      let r = k(e);
      if (r) {
        let o = r !== true && Se(r), s = (o || t).reverse, u = !o || o.reset;
        return Ve({ ...t, loop: e, default: false, pause: void 0, to: !s || Ke(n) ? n : void 0, from: u ? t.from : void 0, reset: u, ...o });
      }
    }
    function Ve(t) {
      let { to: e, from: n } = t = Se(t), r = /* @__PURE__ */ new Set();
      return i.is.obj(e) && vt(e, r), i.is.obj(n) && vt(n, r), t.keys = r.size ? Array.from(r) : null, t;
    }
    function It(t) {
      let e = Ve(t);
      return i.is.und(e.default) && (e.default = ye(e)), e;
    }
    function vt(t, e) {
      (0, i.eachProp)(t, (n, r) => n != null && e.add(r));
    }
    var en = ["onStart", "onRest", "onChange", "onPause", "onResume"];
    function Ct(t, e, n) {
      t.animation[n] = e[n] !== Ge(e, n) ? st(e[n], t.key) : void 0;
    }
    function Le(t, e, ...n) {
      var _a, _b, _c, _d;
      (_b = (_a = t.animation)[e]) == null ? void 0 : _b.call(_a, ...n), (_d = (_c = t.defaultProps)[e]) == null ? void 0 : _d.call(_c, ...n);
    }
    var x = require_dist2();
    var tn = ["onStart", "onChange", "onRest"];
    var nn = 1;
    var pe = class {
      constructor(e, n) {
        __publicField(this, "id", nn++);
        __publicField(this, "springs", {});
        __publicField(this, "queue", []);
        __publicField(this, "ref");
        __publicField(this, "_flush");
        __publicField(this, "_initialProps");
        __publicField(this, "_lastAsyncId", 0);
        __publicField(this, "_active", /* @__PURE__ */ new Set());
        __publicField(this, "_changed", /* @__PURE__ */ new Set());
        __publicField(this, "_started", false);
        __publicField(this, "_item");
        __publicField(this, "_state", { paused: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() });
        __publicField(this, "_events", { onStart: /* @__PURE__ */ new Map(), onChange: /* @__PURE__ */ new Map(), onRest: /* @__PURE__ */ new Map() });
        this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start({ default: true, ...e });
      }
      get idle() {
        return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
      }
      get item() {
        return this._item;
      }
      set item(e) {
        this._item = e;
      }
      get() {
        let e = {};
        return this.each((n, r) => e[r] = n.get()), e;
      }
      set(e) {
        for (let n in e) {
          let r = e[n];
          x.is.und(r) || this.springs[n].set(r);
        }
      }
      update(e) {
        return e && this.queue.push(Ve(e)), this;
      }
      start(e) {
        let { queue: n } = this;
        return e ? n = (0, x.toArray)(e).map(Ve) : this.queue = [], this._flush ? this._flush(this, n) : (Ft(this, n), Ze(this, n));
      }
      stop(e, n) {
        if (e !== !!e && (n = e), n) {
          let r = this.springs;
          (0, x.each)((0, x.toArray)(n), (o) => r[o].stop(!!e));
        } else
          Te(this._state, this._lastAsyncId), this.each((r) => r.stop(!!e));
        return this;
      }
      pause(e) {
        if (x.is.und(e))
          this.start({ pause: true });
        else {
          let n = this.springs;
          (0, x.each)((0, x.toArray)(e), (r) => n[r].pause());
        }
        return this;
      }
      resume(e) {
        if (x.is.und(e))
          this.start({ pause: false });
        else {
          let n = this.springs;
          (0, x.each)((0, x.toArray)(e), (r) => n[r].resume());
        }
        return this;
      }
      each(e) {
        (0, x.eachProp)(this.springs, e);
      }
      _onFrame() {
        let { onStart: e, onChange: n, onRest: r } = this._events, o = this._active.size > 0, s = this._changed.size > 0;
        (o && !this._started || s && !this._started) && (this._started = true, (0, x.flush)(e, ([p, l]) => {
          l.value = this.get(), p(l, this, this._item);
        }));
        let u = !o && this._started, a2 = s || u && r.size ? this.get() : null;
        s && n.size && (0, x.flush)(n, ([p, l]) => {
          l.value = a2, p(l, this, this._item);
        }), u && (this._started = false, (0, x.flush)(r, ([p, l]) => {
          l.value = a2, p(l, this, this._item);
        }));
      }
      eventObserved(e) {
        if (e.type == "change")
          this._changed.add(e.parent), e.idle || this._active.add(e.parent);
        else if (e.type == "idle")
          this._active.delete(e.parent);
        else
          return;
        x.raf.onFrame(this._onFrame);
      }
    };
    function Ze(t, e) {
      return Promise.all(e.map((n) => Vt(t, n))).then((n) => Ue(t, n));
    }
    async function Vt(t, e, n) {
      let { keys: r, to: o, from: s, loop: u, onRest: a2, onResolve: p } = e, l = x.is.obj(e.default) && e.default;
      u && (e.loop = false), o === false && (e.to = null), s === false && (e.from = null);
      let d = x.is.arr(o) || x.is.fun(o) ? o : void 0;
      d ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : (0, x.each)(tn, (T) => {
        let c = e[T];
        if (x.is.fun(c)) {
          let g = t._events[T];
          e[T] = ({ finished: y, cancelled: A }) => {
            let P = g.get(c);
            P ? (y || (P.finished = false), A && (P.cancelled = true)) : g.set(c, { value: null, finished: y || false, cancelled: A || false });
          }, l && (l[T] = e[T]);
        }
      });
      let m = t._state;
      e.pause === !m.paused ? (m.paused = e.pause, (0, x.flushCalls)(e.pause ? m.pauseQueue : m.resumeQueue)) : m.paused && (e.pause = true);
      let h = (r || Object.keys(t.springs)).map((T) => t.springs[T].start(e)), v = e.cancel === true || Ge(e, "cancel") === true;
      (d || v && m.asyncId) && h.push(He(++t._lastAsyncId, { props: e, state: m, actions: { pause: x.noop, resume: x.noop, start(T, c) {
        v ? (Te(m, t._lastAsyncId), c(ee(t))) : (T.onRest = a2, c(We(d, T, m, t)));
      } } })), m.paused && await new Promise((T) => {
        m.resumeQueue.add(T);
      });
      let f = Ue(t, await Promise.all(h));
      if (u && f.finished && !(n && f.noop)) {
        let T = dt(e, u, o);
        if (T)
          return Ft(t, [T]), Vt(t, T, true);
      }
      return p && x.raf.batchedUpdates(() => p(f, t, t.item)), f;
    }
    function Me(t, e) {
      let n = { ...t.springs };
      return e && (0, x.each)((0, x.toArray)(e), (r) => {
        x.is.und(r.keys) && (r = Ve(r)), x.is.obj(r.to) || (r = { ...r, to: void 0 }), Ot(n, r, (o) => _t(o));
      }), mt(t, n), n;
    }
    function mt(t, e) {
      (0, x.eachProp)(e, (n, r) => {
        t.springs[r] || (t.springs[r] = n, (0, x.addFluidObserver)(n, t));
      });
    }
    function _t(t, e) {
      let n = new ue();
      return n.key = t, e && (0, x.addFluidObserver)(n, e), n;
    }
    function Ot(t, e, n) {
      e.keys && (0, x.each)(e.keys, (r) => {
        (t[r] || (t[r] = n(r)))._prepareNode(e);
      });
    }
    function Ft(t, e) {
      (0, x.each)(e, (n) => {
        Ot(t.springs, n, (r) => _t(r, t));
      });
    }
    var tt = Pt(require_react());
    var kt = require_react();
    var Ut = require_dist2();
    var re = ({ children: t, ...e }) => {
      let n = (0, kt.useContext)(et), r = e.pause || !!n.pause, o = e.immediate || !!n.immediate;
      e = (0, Ut.useMemoOne)(() => ({ pause: r, immediate: o }), [r, o]);
      let { Provider: s } = et;
      return tt.createElement(s, { value: e }, t);
    };
    var et = rn(re, {});
    re.Provider = et.Provider;
    re.Consumer = et.Consumer;
    function rn(t, e) {
      return Object.assign(t, tt.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t;
    }
    var q = require_dist2();
    var le = () => {
      let t = [], e = function(r) {
        (0, q.deprecateDirectCall)();
        let o = [];
        return (0, q.each)(t, (s, u) => {
          if (q.is.und(r))
            o.push(s.start());
          else {
            let a2 = n(r, s, u);
            a2 && o.push(s.start(a2));
          }
        }), o;
      };
      e.current = t, e.add = function(r) {
        t.includes(r) || t.push(r);
      }, e.delete = function(r) {
        let o = t.indexOf(r);
        ~o && t.splice(o, 1);
      }, e.pause = function() {
        return (0, q.each)(t, (r) => r.pause(...arguments)), this;
      }, e.resume = function() {
        return (0, q.each)(t, (r) => r.resume(...arguments)), this;
      }, e.set = function(r) {
        (0, q.each)(t, (o, s) => {
          let u = q.is.fun(r) ? r(s, o) : r;
          u && o.set(u);
        });
      }, e.start = function(r) {
        let o = [];
        return (0, q.each)(t, (s, u) => {
          if (q.is.und(r))
            o.push(s.start());
          else {
            let a2 = this._getProps(r, s, u);
            a2 && o.push(s.start(a2));
          }
        }), o;
      }, e.stop = function() {
        return (0, q.each)(t, (r) => r.stop(...arguments)), this;
      }, e.update = function(r) {
        return (0, q.each)(t, (o, s) => o.update(this._getProps(r, o, s))), this;
      };
      let n = function(r, o, s) {
        return q.is.fun(r) ? r(s, o) : r;
      };
      return e._getProps = n, e;
    };
    function je(t, e, n) {
      let r = j.is.fun(e) && e;
      r && !n && (n = []);
      let o = (0, J.useMemo)(() => r || arguments.length == 3 ? le() : void 0, []), s = (0, J.useRef)(0), u = (0, j.useForceUpdate)(), a2 = (0, J.useMemo)(() => ({ ctrls: [], queue: [], flush(g, y) {
        let A = Me(g, y);
        return s.current > 0 && !a2.queue.length && !Object.keys(A).some((I) => !g.springs[I]) ? Ze(g, y) : new Promise((I) => {
          mt(g, A), a2.queue.push(() => {
            I(Ze(g, y));
          }), u();
        });
      } }), []), p = (0, J.useRef)([...a2.ctrls]), l = [], d = (0, j.usePrev)(t) || 0;
      (0, J.useMemo)(() => {
        (0, j.each)(p.current.slice(t, d), (g) => {
          ke(g, o), g.stop(true);
        }), p.current.length = t, m(d, t);
      }, [t]), (0, J.useMemo)(() => {
        m(0, Math.min(d, t));
      }, n);
      function m(g, y) {
        for (let A = g; A < y; A++) {
          let P = p.current[A] || (p.current[A] = new pe(null, a2.flush)), I = r ? r(A, P) : e[A];
          I && (l[A] = It(I));
        }
      }
      let h = p.current.map((g, y) => Me(g, l[y])), v = (0, J.useContext)(re), f = (0, j.usePrev)(v), T = v !== f && Be(v);
      (0, j.useIsomorphicLayoutEffect)(() => {
        s.current++, a2.ctrls = p.current;
        let { queue: g } = a2;
        g.length && (a2.queue = [], (0, j.each)(g, (y) => y())), (0, j.each)(p.current, (y, A) => {
          o == null ? void 0 : o.add(y), T && y.start({ default: v });
          let P = l[A];
          P && (ve(y, P.ref), y.ref ? y.queue.push(P) : y.start(P));
        });
      }), (0, j.useOnce)(() => () => {
        (0, j.each)(a2.ctrls, (g) => g.stop(true));
      });
      let c = h.map((g) => ({ ...g }));
      return o ? [c, o] : c;
    }
    function oe(t, e) {
      let n = Et.is.fun(t), [[r], o] = je(1, n ? t : [t], n ? e || [] : e);
      return n || arguments.length == 2 ? [r, o] : r;
    }
    var wt = require_react();
    var on = () => le();
    var sn = () => (0, wt.useState)(on)[0];
    var nt = require_dist2();
    var an = (t, e) => {
      let n = (0, nt.useConstant)(() => new ue(t, e));
      return (0, nt.useOnce)(() => () => {
        n.stop();
      }), n;
    };
    var be = require_dist2();
    function ht(t, e, n) {
      let r = be.is.fun(e) && e;
      r && !n && (n = []);
      let o = true, s, u = je(t, (a2, p) => {
        let l = r ? r(a2, p) : e;
        return s = l.ref, o = o && l.reverse, l;
      }, n || [{}]);
      if ((0, be.useIsomorphicLayoutEffect)(() => {
        (0, be.each)(u[1].current, (a2, p) => {
          let l = u[1].current[p + (o ? 1 : -1)];
          if (ve(a2, s), a2.ref) {
            l && a2.update({ to: l.springs });
            return;
          }
          l ? a2.start({ to: l.springs }) : a2.start();
        });
      }, n), r || arguments.length == 3) {
        let a2 = s ?? u[1];
        return a2._getProps = (p, l, d) => {
          let m = be.is.fun(p) ? p(d, l) : p;
          if (m) {
            let h = a2.current[d + (m.reverse ? 1 : -1)];
            return h && (m.to = h.springs), m;
          }
        }, u;
      }
      return u[0];
    }
    var Ne = Pt(require_react());
    var ce = require_react();
    var R = require_dist2();
    function gt(t, e, n) {
      let r = R.is.fun(e) && e, { reset: o, sort: s, trail: u = 0, expires: a2 = true, exitBeforeEnter: p = false, onDestroyed: l, ref: d, config: m } = r ? r() : e, h = (0, ce.useMemo)(() => r || arguments.length == 3 ? le() : void 0, []), v = (0, R.toArray)(t), f = [], T = (0, ce.useRef)(null), c = o ? null : T.current;
      (0, R.useIsomorphicLayoutEffect)(() => {
        T.current = f;
      }), (0, R.useOnce)(() => ((0, R.each)(f, (S) => {
        h == null ? void 0 : h.add(S.ctrl), S.ctrl.ref = h;
      }), () => {
        (0, R.each)(T.current, (S) => {
          S.expired && clearTimeout(S.expirationId), ke(S.ctrl, h), S.ctrl.stop(true);
        });
      }));
      let g = pn(v, r ? r() : e, c), y = o && T.current || [];
      (0, R.useIsomorphicLayoutEffect)(() => (0, R.each)(y, ({ ctrl: S, item: b, key: N }) => {
        ke(S, h), k(l, b, N);
      }));
      let A = [];
      if (c && (0, R.each)(c, (S, b) => {
        S.expired ? (clearTimeout(S.expirationId), y.push(S)) : (b = A[b] = g.indexOf(S.key), ~b && (f[b] = S));
      }), (0, R.each)(v, (S, b) => {
        f[b] || (f[b] = { key: g[b], item: S, phase: "mount", ctrl: new pe() }, f[b].ctrl.item = S);
      }), A.length) {
        let S = -1, { leave: b } = r ? r() : e;
        (0, R.each)(A, (N, D) => {
          let M = c[D];
          ~N ? (S = f.indexOf(M), f[S] = { ...M, item: v[N] }) : b && f.splice(++S, 0, M);
        });
      }
      R.is.fun(s) && f.sort((S, b) => s(S.item, b.item));
      let P = -u, I = (0, R.useForceUpdate)(), E = ye(e), w = /* @__PURE__ */ new Map(), O = (0, ce.useRef)(/* @__PURE__ */ new Map()), B = (0, ce.useRef)(false);
      (0, R.each)(f, (S, b) => {
        let N = S.key, D = S.phase, M = r ? r() : e, z, $, Nt = k(M.delay || 0, N);
        if (D == "mount")
          z = M.enter, $ = "enter";
        else {
          let Y = g.indexOf(N) < 0;
          if (D != "leave")
            if (Y)
              z = M.leave, $ = "leave";
            else if (z = M.update)
              $ = "update";
            else
              return;
          else if (!Y)
            z = M.enter, $ = "enter";
          else
            return;
        }
        if (z = k(z, S.item, b), z = R.is.obj(z) ? Se(z) : { to: z }, !z.config) {
          let Y = m || E.config;
          z.config = k(Y, S.item, b, $);
        }
        P += u;
        let me = { ...E, delay: Nt + P, ref: d, immediate: M.immediate, reset: false, ...z };
        if ($ == "enter" && R.is.und(me.from)) {
          let Y = r ? r() : e, Fe = R.is.und(Y.initial) || c ? Y.from : Y.initial;
          me.from = k(Fe, S.item, b);
        }
        let { onResolve: Dt } = me;
        me.onResolve = (Y) => {
          k(Dt, Y);
          let Fe = T.current, ae = Fe.find((qe) => qe.key === N);
          if (!!ae && !(Y.cancelled && ae.phase != "update") && ae.ctrl.idle) {
            let qe = Fe.every((he) => he.ctrl.idle);
            if (ae.phase == "leave") {
              let he = k(a2, ae.item);
              if (he !== false) {
                let ot = he === true ? 0 : he;
                if (ae.expired = true, !qe && ot > 0) {
                  ot <= 2147483647 && (ae.expirationId = setTimeout(I, ot));
                  return;
                }
              }
            }
            qe && Fe.some((he) => he.expired) && (O.current.delete(ae), p && (B.current = true), I());
          }
        };
        let St = Me(S.ctrl, me);
        $ === "leave" && p ? O.current.set(S, { phase: $, springs: St, payload: me }) : w.set(S, { phase: $, springs: St, payload: me });
      });
      let F = (0, ce.useContext)(re), de = (0, R.usePrev)(F), K = F !== de && Be(F);
      (0, R.useIsomorphicLayoutEffect)(() => {
        K && (0, R.each)(f, (S) => {
          S.ctrl.start({ default: F });
        });
      }, [F]), (0, R.each)(w, (S, b) => {
        if (O.current.size) {
          let N = f.findIndex((D) => D.key === b.key);
          f.splice(N, 1);
        }
      }), (0, R.useIsomorphicLayoutEffect)(() => {
        (0, R.each)(O.current.size ? O.current : w, ({ phase: S, payload: b }, N) => {
          let { ctrl: D } = N;
          N.phase = S, h == null ? void 0 : h.add(D), K && S == "enter" && D.start({ default: F }), b && (ve(D, b.ref), (D.ref || h) && !B.current ? D.update(b) : (D.start(b), B.current && (B.current = false)));
        });
      }, o ? void 0 : n);
      let W = (S) => Ne.createElement(Ne.Fragment, null, f.map((b, N) => {
        let { springs: D } = w.get(b) || b.ctrl, M = S({ ...D }, b.item, b, N);
        return M && M.type ? Ne.createElement(M.type, { ...M.props, key: R.is.str(b.key) || R.is.num(b.key) ? b.key : b.ctrl.id, ref: M.ref }) : M;
      }));
      return h ? [W, h] : W;
    }
    var un = 1;
    function pn(t, { key: e, keys: n = e }, r) {
      if (n === null) {
        let o = /* @__PURE__ */ new Set();
        return t.map((s) => {
          let u = r && r.find((a2) => a2.item === s && a2.phase !== "leave" && !o.has(a2));
          return u ? (o.add(u), u.key) : un++;
        });
      }
      return R.is.und(n) ? t : R.is.fun(n) ? t.map(n) : (0, R.toArray)(n);
    }
    var _e = require_dist2();
    var ln = ({ container: t, ...e } = {}) => {
      let [n, r] = oe(() => ({ scrollX: 0, scrollY: 0, scrollXProgress: 0, scrollYProgress: 0, ...e }), []);
      return (0, _e.useIsomorphicLayoutEffect)(() => {
        let o = (0, _e.onScroll)(({ x: s, y: u }) => {
          r.start({ scrollX: s.current, scrollXProgress: s.progress, scrollY: u.current, scrollYProgress: u.progress });
        }, { container: (t == null ? void 0 : t.current) || void 0 });
        return () => {
          (0, _e.each)(Object.values(n), (s) => s.stop()), o();
        };
      }, []), n;
    };
    var Oe = require_dist2();
    var cn = ({ container: t, ...e }) => {
      let [n, r] = oe(() => ({ width: 0, height: 0, ...e }), []);
      return (0, Oe.useIsomorphicLayoutEffect)(() => {
        let o = (0, Oe.onResize)(({ width: s, height: u }) => {
          r.start({ width: s, height: u, immediate: n.width.get() === 0 || n.height.get() === 0 });
        }, { container: (t == null ? void 0 : t.current) || void 0 });
        return () => {
          (0, Oe.each)(Object.values(n), (s) => s.stop()), o();
        };
      }, []), n;
    };
    var rt = require_react();
    var De = require_dist2();
    var fn = { any: 0, all: 1 };
    function dn(t, e) {
      let [n, r] = (0, rt.useState)(false), o = (0, rt.useRef)(), s = De.is.fun(t) && t, u = s ? s() : {}, { to: a2 = {}, from: p = {}, ...l } = u, d = s ? e : t, [m, h] = oe(() => ({ from: p, ...l }), []);
      return (0, De.useIsomorphicLayoutEffect)(() => {
        let v = o.current, { root: f, once: T, amount: c = "any", ...g } = d ?? {};
        if (!v || T && n || typeof IntersectionObserver > "u")
          return;
        let y = /* @__PURE__ */ new WeakMap(), A = () => (a2 && h.start(a2), r(true), T ? void 0 : () => {
          p && h.start(p), r(false);
        }), P = (E) => {
          E.forEach((w) => {
            let O = y.get(w.target);
            if (w.isIntersecting !== Boolean(O))
              if (w.isIntersecting) {
                let B = A();
                De.is.fun(B) ? y.set(w.target, B) : I.unobserve(w.target);
              } else
                O && (O(), y.delete(w.target));
          });
        }, I = new IntersectionObserver(P, { root: f && f.current || void 0, threshold: typeof c == "number" || Array.isArray(c) ? c : fn[c], ...g });
        return I.observe(v), () => I.unobserve(v);
      }, [d]), s ? [o, m] : [o, n];
    }
    function mn({ children: t, ...e }) {
      return t(oe(e));
    }
    var Lt = require_dist2();
    function hn({ items: t, children: e, ...n }) {
      let r = ht(t.length, n);
      return t.map((o, s) => {
        let u = e(o, s);
        return Lt.is.fun(u) ? u(r[s]) : u;
      });
    }
    function gn({ items: t, children: e, ...n }) {
      return gt(t, n)(e);
    }
    var jt = require_dist2();
    var C = require_dist2();
    var ie = require_dist3();
    var se = class extends te {
      constructor(n, r) {
        super();
        __publicField(this, "key");
        __publicField(this, "idle", true);
        __publicField(this, "calc");
        __publicField(this, "_active", /* @__PURE__ */ new Set());
        this.source = n;
        this.calc = (0, C.createInterpolator)(...r);
        let o = this._get(), s = (0, ie.getAnimatedType)(o);
        (0, ie.setAnimated)(this, s.create(o));
      }
      advance(n) {
        let r = this._get(), o = this.get();
        (0, C.isEqual)(r, o) || ((0, ie.getAnimated)(this).setValue(r), this._onChange(r, this.idle)), !this.idle && Mt(this._active) && yt(this);
      }
      _get() {
        let n = C.is.arr(this.source) ? this.source.map(C.getFluidValue) : (0, C.toArray)((0, C.getFluidValue)(this.source));
        return this.calc(...n);
      }
      _start() {
        this.idle && !Mt(this._active) && (this.idle = false, (0, C.each)((0, ie.getPayload)(this), (n) => {
          n.done = false;
        }), C.Globals.skipAnimation ? (C.raf.batchedUpdates(() => this.advance()), yt(this)) : C.frameLoop.start(this));
      }
      _attach() {
        let n = 1;
        (0, C.each)((0, C.toArray)(this.source), (r) => {
          (0, C.hasFluidValue)(r) && (0, C.addFluidObserver)(r, this), Ee(r) && (r.idle || this._active.add(r), n = Math.max(n, r.priority + 1));
        }), this.priority = n, this._start();
      }
      _detach() {
        (0, C.each)((0, C.toArray)(this.source), (n) => {
          (0, C.hasFluidValue)(n) && (0, C.removeFluidObserver)(n, this);
        }), this._active.clear(), yt(this);
      }
      eventObserved(n) {
        n.type == "change" ? n.idle ? this.advance() : (this._active.add(n.parent), this._start()) : n.type == "idle" ? this._active.delete(n.parent) : n.type == "priority" && (this.priority = (0, C.toArray)(this.source).reduce((r, o) => Math.max(r, (Ee(o) ? o.priority : 0) + 1), 0));
      }
    };
    function yn(t) {
      return t.idle !== false;
    }
    function Mt(t) {
      return !t.size || Array.from(t).every(yn);
    }
    function yt(t) {
      t.idle || (t.idle = true, (0, C.each)((0, ie.getPayload)(t), (e) => {
        e.done = true;
      }), (0, C.callFluidObservers)(t, { type: "idle", parent: t }));
    }
    var Sn = (t, ...e) => new se(t, e);
    var Pn = (t, ...e) => ((0, jt.deprecateInterpolate)(), new se(t, e));
    var Ae = require_dist2();
    Ae.Globals.assign({ createStringInterpolator: Ae.createStringInterpolator, to: (t, e) => new se(t, e) });
    var Tn = Ae.frameLoop.advance;
    var fe = require_dist2();
    L(U, require_dist4(), module.exports);
  }
});

// node_modules/@react-spring/web/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@react-spring/web/dist/index.js"(exports, module) {
    "use strict";
    var v = Object.defineProperty;
    var T = Object.getOwnPropertyDescriptor;
    var j = Object.getOwnPropertyNames;
    var R = Object.prototype.hasOwnProperty;
    var W = (t, e) => {
      for (var o in e)
        v(t, o, { get: e[o], enumerable: true });
    };
    var O = (t, e, o, i) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let s of j(e))
          !R.call(t, s) && s !== o && v(t, s, { get: () => e[s], enumerable: !(i = T(e, s)) || i.enumerable });
      return t;
    };
    var l = (t, e, o) => (O(t, e, "default"), o && O(o, e, "default"));
    var _ = (t) => O(v({}, "__esModule", { value: true }), t);
    var u = {};
    W(u, { a: () => q, animated: () => q });
    module.exports = _(u);
    var S = require_dist5();
    var E = require_react_dom();
    var x = require_dist2();
    var P = require_dist3();
    var C = /^--/;
    function $(t, e) {
      return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !C.test(t) && !(h.hasOwnProperty(t) && h[t]) ? e + "px" : ("" + e).trim();
    }
    var A = {};
    function I(t, e) {
      if (!t.nodeType || !t.setAttribute)
        return false;
      let o = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", { style: i, children: s, scrollTop: d, scrollLeft: m, viewBox: p, ...a2 } = e, f = Object.values(a2), b = Object.keys(a2).map((n) => o || t.hasAttribute(n) ? n : A[n] || (A[n] = n.replace(/([A-Z])/g, (c) => "-" + c.toLowerCase())));
      s !== void 0 && (t.textContent = s);
      for (let n in i)
        if (i.hasOwnProperty(n)) {
          let c = $(n, i[n]);
          C.test(n) ? t.style.setProperty(n, c) : t.style[n] = c;
        }
      b.forEach((n, c) => {
        t.setAttribute(n, f[c]);
      }), d !== void 0 && (t.scrollTop = d), m !== void 0 && (t.scrollLeft = m), p !== void 0 && t.setAttribute("viewBox", p);
    }
    var h = { animationIterationCount: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true };
    var G = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1);
    var M = ["Webkit", "Ms", "Moz", "O"];
    h = Object.keys(h).reduce((t, e) => (M.forEach((o) => t[G(o, e)] = t[e]), t), h);
    var F = require_dist3();
    var r = require_dist2();
    var N = /^(matrix|translate|scale|rotate|skew)/;
    var U = /^(translate)/;
    var D = /^(rotate|skew)/;
    var k = (t, e) => r.is.num(t) && t !== 0 ? t + e : t;
    var g = (t, e) => r.is.arr(t) ? t.every((o) => g(o, e)) : r.is.num(t) ? t === e : parseFloat(t) === e;
    var y = class extends F.AnimatedObject {
      constructor({ x: e, y: o, z: i, ...s }) {
        let d = [], m = [];
        (e || o || i) && (d.push([e || 0, o || 0, i || 0]), m.push((p) => [`translate3d(${p.map((a2) => k(a2, "px")).join(",")})`, g(p, 0)])), (0, r.eachProp)(s, (p, a2) => {
          if (a2 === "transform")
            d.push([p || ""]), m.push((f) => [f, f === ""]);
          else if (N.test(a2)) {
            if (delete s[a2], r.is.und(p))
              return;
            let f = U.test(a2) ? "px" : D.test(a2) ? "deg" : "";
            d.push((0, r.toArray)(p)), m.push(a2 === "rotate3d" ? ([b, n, c, w]) => [`rotate3d(${b},${n},${c},${k(w, f)})`, g(w, 0)] : (b) => [`${a2}(${b.map((n) => k(n, f)).join(",")})`, g(b, a2.startsWith("scale") ? 1 : 0)]);
          }
        }), d.length && (s.transform = new V(d, m)), super(s);
      }
    };
    var V = class extends r.FluidValue {
      constructor(o, i) {
        super();
        __publicField(this, "_value", null);
        this.inputs = o;
        this.transforms = i;
      }
      get() {
        return this._value || (this._value = this._get());
      }
      _get() {
        let o = "", i = true;
        return (0, r.each)(this.inputs, (s, d) => {
          let m = (0, r.getFluidValue)(s[0]), [p, a2] = this.transforms[d](r.is.arr(m) ? m : s.map(r.getFluidValue));
          o += " " + p, i = i && a2;
        }), i ? "none" : o;
      }
      observerAdded(o) {
        o == 1 && (0, r.each)(this.inputs, (i) => (0, r.each)(i, (s) => (0, r.hasFluidValue)(s) && (0, r.addFluidObserver)(s, this)));
      }
      observerRemoved(o) {
        o == 0 && (0, r.each)(this.inputs, (i) => (0, r.each)(i, (s) => (0, r.hasFluidValue)(s) && (0, r.removeFluidObserver)(s, this)));
      }
      eventObserved(o) {
        o.type == "change" && (this._value = null), (0, r.callFluidObservers)(this, o);
      }
    };
    var L = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
    l(u, require_dist5(), module.exports);
    S.Globals.assign({ batchedUpdates: E.unstable_batchedUpdates, createStringInterpolator: x.createStringInterpolator, colors: x.colors });
    var H = (0, P.createHost)(L, { applyAnimatedValues: I, createAnimatedStyle: (t) => new y(t), getComponentProps: ({ scrollTop: t, scrollLeft: e, ...o }) => o });
    var q = H.animated;
  }
});

// node_modules/react-tinder-card/index.js
var require_react_tinder_card = __commonJS({
  "node_modules/react-tinder-card/index.js"(exports, module) {
    var React = require_react();
    var { useSpring: useSpring2, animated: animated2 } = require_dist6();
    var height = window.innerHeight;
    var width = window.innerWidth;
    var settings = {
      maxTilt: 25,
      // in deg
      rotationPower: 50,
      swipeThreshold: 0.5
      // need to update this threshold for RN (1.5 seems reasonable...?)
    };
    var physics = {
      touchResponsive: {
        friction: 50,
        tension: 2e3
      },
      animateOut: {
        friction: 30,
        tension: 400
      },
      animateBack: {
        friction: 10,
        tension: 200
      }
    };
    var pythagoras = (x, y) => {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };
    var normalize = (vector) => {
      const length = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
      return { x: vector.x / length, y: vector.y / length };
    };
    var animateOut = async (gesture, setSpringTarget) => {
      const diagonal = pythagoras(height, width);
      const velocity = pythagoras(gesture.x, gesture.y);
      const finalX = diagonal * gesture.x;
      const finalY = diagonal * gesture.y;
      const finalRotation = gesture.x * 45;
      const duration = diagonal / velocity;
      setSpringTarget.start({
        xyrot: [finalX, finalY, finalRotation],
        config: { duration }
      });
      return await new Promise(
        (resolve) => setTimeout(() => {
          resolve();
        }, duration)
      );
    };
    var animateBack = (setSpringTarget) => {
      return new Promise((resolve) => {
        setSpringTarget.start({ xyrot: [0, 0, 0], config: physics.animateBack, onRest: resolve });
      });
    };
    var getSwipeDirection = (property) => {
      if (Math.abs(property.x) > Math.abs(property.y)) {
        if (property.x > settings.swipeThreshold) {
          return "right";
        } else if (property.x < -settings.swipeThreshold) {
          return "left";
        }
      } else {
        if (property.y > settings.swipeThreshold) {
          return "down";
        } else if (property.y < -settings.swipeThreshold) {
          return "up";
        }
      }
      return "none";
    };
    var AnimatedDiv = animated2.div;
    var TinderCard = React.forwardRef(
      ({ flickOnSwipe = true, children, onSwipe, onCardLeftScreen, className, preventSwipe = [], swipeRequirementType = "velocity", swipeThreshold = settings.swipeThreshold, onSwipeRequirementFulfilled, onSwipeRequirementUnfulfilled }, ref) => {
        const [{ xyrot }, setSpringTarget] = useSpring2(() => ({
          xyrot: [0, 0, 0],
          config: physics.touchResponsive
        }));
        settings.swipeThreshold = swipeThreshold;
        React.useImperativeHandle(ref, () => ({
          async swipe(dir = "right") {
            if (onSwipe)
              onSwipe(dir);
            const power = 1.3;
            const disturbance = (Math.random() - 0.5) / 2;
            if (dir === "right") {
              await animateOut({ x: power, y: disturbance }, setSpringTarget);
            } else if (dir === "left") {
              await animateOut({ x: -power, y: disturbance }, setSpringTarget);
            } else if (dir === "up") {
              await animateOut({ x: disturbance, y: power }, setSpringTarget);
            } else if (dir === "down") {
              await animateOut({ x: disturbance, y: -power }, setSpringTarget);
            }
            if (onCardLeftScreen)
              onCardLeftScreen(dir);
          },
          async restoreCard() {
            await animateBack(setSpringTarget);
          }
        }));
        const handleSwipeReleased = React.useCallback(
          async (setSpringTarget2, gesture) => {
            const dir = getSwipeDirection({
              x: swipeRequirementType === "velocity" ? gesture.vx : gesture.dx,
              y: swipeRequirementType === "velocity" ? gesture.vy : gesture.dy
            });
            if (dir !== "none") {
              if (flickOnSwipe) {
                if (!preventSwipe.includes(dir)) {
                  if (onSwipe)
                    onSwipe(dir);
                  await animateOut(swipeRequirementType === "velocity" ? {
                    x: gesture.vx,
                    y: gesture.vy
                  } : normalize({ x: gesture.dx, y: gesture.dy }), setSpringTarget2, swipeRequirementType);
                  if (onCardLeftScreen)
                    onCardLeftScreen(dir);
                  return;
                }
              }
            }
            animateBack(setSpringTarget2);
          },
          [swipeRequirementType, flickOnSwipe, preventSwipe, onSwipe, onCardLeftScreen]
        );
        let swipeThresholdFulfilledDirection = "none";
        const gestureStateFromWebEvent = (ev, startPositon, lastPosition, isTouch) => {
          let dx = isTouch ? ev.touches[0].clientX - startPositon.x : ev.clientX - startPositon.x;
          let dy = isTouch ? ev.touches[0].clientY - startPositon.y : ev.clientY - startPositon.y;
          if (startPositon.x === 0 && startPositon.y === 0) {
            dx = 0;
            dy = 0;
          }
          const vx = -(dx - lastPosition.dx) / (lastPosition.timeStamp - Date.now());
          const vy = -(dy - lastPosition.dy) / (lastPosition.timeStamp - Date.now());
          const gestureState = { dx, dy, vx, vy, timeStamp: Date.now() };
          return gestureState;
        };
        React.useLayoutEffect(() => {
          let startPositon = { x: 0, y: 0 };
          let lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };
          let isClicking = false;
          element.current.addEventListener("touchstart", (ev) => {
            if (!ev.srcElement.className.includes("pressable") && ev.cancelable) {
              ev.preventDefault();
            }
            const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, true);
            lastPosition = gestureState;
            startPositon = { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
          });
          element.current.addEventListener("mousedown", (ev) => {
            isClicking = true;
            const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, false);
            lastPosition = gestureState;
            startPositon = { x: ev.clientX, y: ev.clientY };
          });
          const handleMove = (gestureState) => {
            if (onSwipeRequirementFulfilled || onSwipeRequirementUnfulfilled) {
              const dir = getSwipeDirection({
                x: swipeRequirementType === "velocity" ? gestureState.vx : gestureState.dx,
                y: swipeRequirementType === "velocity" ? gestureState.vy : gestureState.dy
              });
              if (dir !== swipeThresholdFulfilledDirection) {
                swipeThresholdFulfilledDirection = dir;
                if (swipeThresholdFulfilledDirection === "none") {
                  if (onSwipeRequirementUnfulfilled)
                    onSwipeRequirementUnfulfilled();
                } else {
                  if (onSwipeRequirementFulfilled)
                    onSwipeRequirementFulfilled(dir);
                }
              }
            }
            let rot = gestureState.vx * 15;
            rot = Math.max(Math.min(rot, settings.maxTilt), -settings.maxTilt);
            setSpringTarget.start({ xyrot: [gestureState.dx, gestureState.dy, rot], config: physics.touchResponsive });
          };
          window.addEventListener("mousemove", (ev) => {
            if (!isClicking)
              return;
            const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, false);
            lastPosition = gestureState;
            handleMove(gestureState);
          });
          window.addEventListener("mouseup", (ev) => {
            if (!isClicking)
              return;
            isClicking = false;
            handleSwipeReleased(setSpringTarget, lastPosition);
            startPositon = { x: 0, y: 0 };
            lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };
          });
          element.current.addEventListener("touchmove", (ev) => {
            const gestureState = gestureStateFromWebEvent(ev, startPositon, lastPosition, true);
            lastPosition = gestureState;
            handleMove(gestureState);
          });
          element.current.addEventListener("touchend", (ev) => {
            handleSwipeReleased(setSpringTarget, lastPosition);
            startPositon = { x: 0, y: 0 };
            lastPosition = { dx: 0, dy: 0, vx: 0, vy: 0, timeStamp: Date.now() };
          });
        });
        const element = React.useRef();
        return React.createElement(AnimatedDiv, {
          ref: element,
          className,
          style: {
            transform: xyrot.to((x, y, rot) => `translate3d(${x}px, ${y}px, ${0}px) rotate(${rot}deg)`)
          },
          children
        });
      }
    );
    module.exports = TinderCard;
  }
});
export default require_react_tinder_card();
//# sourceMappingURL=react-tinder-card.js.map
